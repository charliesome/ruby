/*
vim:ft=c
*/

|.arch x64
|.actionlist dasm_actionlist

static void
panic()
{
    rb_bug("JIT panicked");
}

static void
jit_instruction(jit_ctx_t *ctx)
{
    VALUE opcode = next(ctx);
    switch (opcode) {
      case BIN(trace): {
	next(ctx); /* trace type */
	break;
      }
      case BIN(putobject_OP_INT2FIX_O_1_C_): {
	VALUE value = INT2FIX(1);
	| push value
	break;
      }
      case BIN(putobject): {
	VALUE value = next(ctx);
	| push value
	break;
      }
      case BIN(opt_plus): {
	next(ctx);
	| pop rax
	| pop rbx
	| mov rcx, rbx
	/* check both LSBs to ensure both operands are fixnums */
	| and rcx, rax
	| bt rcx, 0
	| jnc >1
	/* check Fixnum#+ has not been redefined */
	| mov cx, [(&ruby_vm_redefined_flag[BOP_PLUS])]
	| test cx, FIXNUM_REDEFINED_OP_FLAG
	| jz >2
	/* either rax or rbx is not a fixnum, fall back to normal method call */
	|1:
	| and rsp, ~15
	| mov64 rax, (uint64_t)panic
	| call rax
	|2:
	/* both rax and rbx are fixnums */
	| dec rbx
	| add rax, rbx
	/* perform a normal method call if an overflow occurred */
	| jo >1
	| push rax
	break;
      }
      case BIN(getlocal_OP__WC__0): {
	| mov rax, [rsi + offsetof(rb_control_frame_t, ep)]
	| mov rax, [rax - sizeof(VALUE) * next(ctx)]
	| push rax
	break;
      }
      case BIN(setlocal_OP__WC__0): {
	| pop rbx
	| mov rax, [rsi + offsetof(rb_control_frame_t, ep)]
	| lea rax, [rax - sizeof(VALUE) * next(ctx)]
	| mov [rax], rbx
	break;
      }
      case BIN(putnil): {
	| push Qnil
	break;
      }
      case BIN(leave): {
	/* pop CFP */
	| mov rax, [rdi + offsetof(rb_thread_t, cfp)]
	| add rax, sizeof(rb_control_frame_t)
	| mov [rdi + offsetof(rb_thread_t, cfp)], rax
	/* return */
	| pop rax
	| ret
	break;
      }
      default: {
	const char* insn_name = insn_name_info[opcode];
	free_ctx(ctx);
	rb_raise(JITError, "unknown opcode %s", insn_name);
      }
    }
}
